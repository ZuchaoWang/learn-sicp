import inspect
from typing import Any, Callable, Dict, Generic, List, Type, TypeVar, Union

from sicp414_evaluator import UndefVal, is_truthy, scheme_panic

'''machine language syntax, we will skip parsing and directly provide classes'''


class Mxpr:
    '''machine language expression'''
    pass


class ConstMxpr(Mxpr):
    '''value can be any type, we cannot type it precisely'''

    def __init__(self, value: Any):
        self.value = value


class RegMxpr(Mxpr):
    '''name is register name'''

    def __init__(self, name: str):
        self.name = name


class LabelMxpr(Mxpr):
    '''name is label name'''

    def __init__(self, name: str):
        self.name = name


class OpMxpr(Mxpr):
    def __init__(self, operator: str, operands: List[Union[ConstMxpr, RegMxpr]]):
        self.operator = operator
        self.operands = operands


class Mstmt:
    '''machine language statement'''
    pass


class InstMstmt(Mstmt):
    pass


class AssignMstmt(InstMstmt):
    def __init__(self, name: str, value: Mxpr):
        self.name = name
        self.value = value


class PerformMstmt(InstMstmt):
    def __init__(self, value: OpMxpr):
        self.value = value


class TestMstmt(InstMstmt):
    def __init__(self, value: OpMxpr):
        self.value = value


class BranchMstmt(InstMstmt):
    def __init__(self, label: LabelMxpr):
        self.label = label


class GotoMstmt(InstMstmt):
    def __init__(self, dest: Union[RegMxpr, LabelMxpr]):
        self.dest = dest


class SaveMstmt(InstMstmt):
    def __init__(self, name: str):
        self.name = name


class RestoreMstmt(InstMstmt):
    def __init__(self, name: str):
        self.name = name


class LabelMstmt(Mstmt):
    def __init__(self, name: str):
        self.name = name


'''register machine model'''


class RegInst:
    '''exec generated by static analysis at assemble time'''

    def __init__(self, code: InstMstmt, exec: Callable):
        self.code = code
        self.exec = exec


class RegInstPtr:
    '''used for label and pc'''

    def __init__(self, insts: List[RegInst], index: int):
        self.insts = insts
        self.index = index


class RegMachineState:
    def __init__(self, stack: List[Any], regs: Dict[str, Any], ops: Dict[str, Callable]):
        self.stack = stack
        self.regs = regs
        self.ops = ops


GenericRegMachineState = TypeVar(
    "GenericRegMachineState", bound=RegMachineState)


class RegMachine:
    def __init__(self, state: RegMachineState, instructions: List[RegInst]):
        self.state = state
        self.instructions = instructions


def make_reg_table(names: List[str]):
    d: Dict[str, Any] = {
        'pc': None,
        'flag': None
    }
    for name in names:
        d[name] = None
    return d


'''
assemble performs additional static analysis to increase performance
it turns labels into instruction pointer
instructions into executable
'''

class SchemeAssembleError(Exception):
    def __init__(self, message):
        self.message = message


def assemble(code: List[Mstmt], state: GenericRegMachineState):
    instructions: List[RegInst] = []
    symbol_table: Dict[str, RegInstPtr] = {}
    try:
        '''first pass to construct symbol table'''
        def empty_exec(): return None
        for c in code:
            if isinstance(c, LabelMstmt):
                symbol_table[c.name] = RegInstPtr(instructions, len(instructions))
            elif isinstance(c, InstMstmt):
                '''initially we don't assemble instructions'''
                instructions.append(RegInst(c, empty_exec))
            else:
                raise SchemeAssembleError('wrong machine statement type %s' % type(c).__name__)
        '''second pass to assemble instructions'''
        for inst in instructions:
            inst.exec = assemble_mstmt(inst.code, symbol_table, state)
        return instructions
    except SchemeAssembleError as err:
        scheme_panic(err.message)

GenericMxpr = TypeVar("GenericMxpr", bound=Mxpr)

AssembleMxprFuncType = Callable[[
    GenericMxpr, Dict[str, RegInstPtr], GenericRegMachineState], Callable]

_assemble_mxpr_rules: Dict[Type, AssembleMxprFuncType] = {}


def update_assemble_mxpr_rules(rules: Dict[Type, AssembleMxprFuncType]):
    _assemble_mxpr_rules.update(rules)


def assemble_mxpr(mxpr: Mxpr, symbol_table: Dict[str, RegInstPtr], state: GenericRegMachineState):
    func = _assemble_mxpr_rules[type(mxpr)]
    return func(mxpr, symbol_table, state)


def assemble_mxpr_const(mxpr: ConstMxpr, symbol_table: Dict[str, RegInstPtr], state: RegMachineState):
    '''constant value is ready at assemble time'''
    value = mxpr.value
    return lambda: value


def assemble_mxpr_reg(mxpr: RegMxpr, symbol_table: Dict[str, RegInstPtr], state: RegMachineState):
    '''register value should be calulated at runtime'''
    regs = state.regs
    name = mxpr.name
    return lambda: regs[name]


def assemble_mxpr_label(mxpr: LabelMxpr, symbol_table: Dict[str, RegInstPtr], state: RegMachineState):
    '''label is ready at assemble time'''
    label = symbol_table[mxpr.name]
    return lambda: label


def assemble_mxpr_op(mxpr: OpMxpr, symbol_table: Dict[str, RegInstPtr], state: RegMachineState):
    '''operator is ready at assemble time, but operands at runtime'''
    operator = state.ops[mxpr.operator]
    arity = len(inspect.getfullargspec(operator).args)
    if arity != len(mxpr.operands):
        raise SchemeAssembleError('%s operation need %d arguments, now %d provided' % (
            mxpr.operator, arity, len(mxpr.operands)))
    get_operands = [assemble_mxpr(operand, symbol_table, state)
                    for operand in mxpr.operands]
    return lambda: operator(*[gop() for gop in get_operands])


update_assemble_mxpr_rules({
    ConstMxpr: assemble_mxpr_const,
    RegMxpr: assemble_mxpr_reg,
    LabelMxpr: assemble_mxpr_label,
    OpMxpr: assemble_mxpr_op
})

GenericInstMstmt = TypeVar("GenericInstMstmt", bound=InstMstmt)

AssembleMstmtFuncType = Callable[[
    GenericInstMstmt, Dict[str, RegInstPtr], GenericRegMachineState], Callable]

_assemble_mstmt_rules: Dict[Type, AssembleMstmtFuncType] = {}


def update_assemble_mstmt_rules(rules: Dict[Type, AssembleMstmtFuncType]):
    _assemble_mstmt_rules.update(rules)


def assemble_mstmt(mstmt: InstMstmt, symbol_table: Dict[str, RegInstPtr], state: GenericRegMachineState):
    func = _assemble_mstmt_rules[type(mstmt)]
    return func(mstmt, symbol_table, state)


def advance_pc(regs: Dict[str, Any]):
    pc: RegInstPtr = regs['pc']
    new_pc = RegInstPtr(pc.insts, pc.index+1)
    regs['pc'] = new_pc


def assemble_mstmt_assign(mstmt: AssignMstmt, symbol_table: Dict[str, RegInstPtr], state: RegMachineState):
    regs = state.regs
    name = mstmt.name
    get_value = assemble_mxpr(mstmt.value, symbol_table, state)
    def run():
        regs[name] = get_value()
        advance_pc(regs)
    return run


def assemble_mstmt_perform(mstmt: PerformMstmt, symbol_table: Dict[str, RegInstPtr], state: RegMachineState):
    regs = state.regs
    perform_op = assemble_mxpr_op(mstmt.value, symbol_table, state)
    def run():
        perform_op()
        advance_pc(regs)
    return run


def assemble_mstmt_test(mstmt: TestMstmt, symbol_table: Dict[str, RegInstPtr], state: RegMachineState):
    regs = state.regs
    get_value = assemble_mxpr_op(mstmt.value, symbol_table, state)
    def run():
        regs['flag'] = get_value()
        advance_pc(regs)
    return run


def assemble_mstmt_branch(mstmt: BranchMstmt, symbol_table: Dict[str, RegInstPtr], state: RegMachineState):
    regs = state.regs
    get_label = assemble_mxpr_label(mstmt.label, symbol_table, state)
    def run():
        if is_truthy(regs['flag']):
            regs['pc'] = get_label()
        else:
            advance_pc(regs)
    return run


def assemble_mstmt_goto(mstmt: GotoMstmt, symbol_table: Dict[str, RegInstPtr], state: RegMachineState):
    regs = state.regs
    get_label = assemble_mxpr(mstmt.dest, symbol_table, state)
    def run():
        regs['pc'] = get_label()
    return run


def assemble_mstmt_save(mstmt: SaveMstmt, symbol_table: Dict[str, RegInstPtr], state: RegMachineState):
    regs = state.regs
    name = mstmt.name
    stack = state.stack
    def run():
        stack.append(regs[name])
        advance_pc(regs)
    return run


def assemble_mstmt_restore(mstmt: RestoreMstmt, symbol_table: Dict[str, RegInstPtr], state: RegMachineState):
    regs = state.regs
    name = mstmt.name
    stack = state.stack
    def run():
        regs[name] = stack.pop()
        advance_pc(regs)
    return run


update_assemble_mstmt_rules({
    AssignMstmt: assemble_mstmt_assign,
    PerformMstmt: assemble_mstmt_perform,
    TestMstmt: assemble_mstmt_test,
    BranchMstmt: assemble_mstmt_branch,
    GotoMstmt: assemble_mstmt_goto,
    SaveMstmt: assemble_mstmt_save,
    RestoreMstmt: assemble_mstmt_restore
})

def make_machine(reg_names: List[str], ops: Dict[str, Callable], code: List[Mstmt]):
    stack: List[Any] = []
    regs = make_reg_table(reg_names)
    state = RegMachineState(stack, regs, ops)
    instructions = assemble(code, state)
    machine = RegMachine(state, instructions)
    return machine

def execute_machine(machine: RegMachine):
    regs = machine.state.regs
    regs['pc'] = RegInstPtr(machine.instructions, 0)
    while regs['pc'].index < len(regs['pc'].insts):
        inst = regs['pc'].insts[regs['pc'].index]
        inst.exec()
