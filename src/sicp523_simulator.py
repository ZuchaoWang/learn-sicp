from typing import Any, Callable, Dict, List, Type, TypeVar, Union

'''machine language syntax, we will skip parsing and directly provide classes'''

class Mxpr:
    '''machine language expression'''
    pass


class ConstMxpr(Mxpr):
    '''value can be any type, we cannot type it precisely'''

    def __init__(self, value: Any):
        self.value = value


class RegMxpr(Mxpr):
    '''name is register name'''

    def __init__(self, name: str):
        self.name = name


class LabelMxpr(Mxpr):
    '''name is label name'''

    def __init__(self, name: str):
        self.name = name


class OpMxpr(Mxpr):
    def __init__(self, operator: str, operands: List[Union[ConstMxpr, RegMxpr]]):
        self.operator = operator
        self.operands = operands


class Mstmt:
    '''machine language statement'''
    pass


class InstMstmt(Mstmt):
    pass


class AssignMstmt(InstMstmt):
    def __init__(self, reg: str, value: Mxpr):
        self.reg = reg
        self.value = value


class PerformMstmt(InstMstmt):
    def __init__(self, value: OpMxpr):
        self.value = value


class TestMstmt(InstMstmt):
    def __init__(self, value: OpMxpr):
        self.value = value


class BranchMstmt(InstMstmt):
    def __init__(self, label: LabelMxpr):
        self.label = label


class GotoMstmt(InstMstmt):
    def __init__(self, dest: Union[RegMxpr, LabelMxpr]):
        self.dest = dest


class SaveMstmt(InstMstmt):
    def __init__(self, reg: str):
        self.reg = reg


class RestoreMstmt(InstMstmt):
    def __init__(self, reg: str):
        self.reg = reg


class LabelMstmt(Mstmt):
    def __init__(self, name: str):
        self.name = name


'''register machine model'''

class RegInst:
    '''exec generated by static analysis at assemble time'''
    def __init__(self, code: InstMstmt, exec: Callable):
        self.code = code
        self.exec = exec

class RegInstPtr:
    '''used for label and pc'''
    def __init__(self, insts: List[RegInst], index: int):
        self.insts = insts
        self.index = index

class RegMachine:
    def __init__(self, stack: List[Any], regs: Dict[str, Any], ops: Dict[str, Callable], instructions: List[RegInst]):
        self.stack = stack
        self.regs = regs
        self.ops = ops
        self.instructions = instructions

def make_reg_table(names: List[str]):
    d: Dict[str, Any] = {
      'pc': None,
      'flag': None
    }
    for name in names:
        d[name] = None
    return d

'''
assemble performs additional static analysis for performance
it turns labels into instruction pointer
instructions into executable
'''

def assemble(code: List[Mstmt], stack: List[Any], regs: Dict[str, Any], ops: Dict[str, Callable]):
    instructions: List[RegInst]  = []
    labels: Dict[str, RegInstPtr] = {}
    for c in code:
        if isinstance(c, LabelMstmt):
            labels[c.name] = RegInstPtr(instructions, len(instructions))
        elif isinstance(c, InstMstmt):
            instructions.append(RegInst(c, assemble_stmt(c, stack, regs, ops)))
        else:
            assert False

GenericInstStmt = TypeVar("GenericInstStmt", bound=InstMstmt)

AssembleStmtFuncType = Callable[[GenericInstStmt, List[Any], Dict[str, Any], Dict[str, Callable]], Callable]

_assemble_stmt_rules: Dict[Type, AssembleStmtFuncType] = {}

def update_assemble_stmt_rules(rules: Dict[Type, AssembleStmtFuncType]):
    _assemble_stmt_rules.update(rules)

def assemble_stmt(stmt: InstMstmt, stack: List[Any], regs: Dict[str, Any], ops: Dict[str, Callable]):
    func = _assemble_stmt_rules[type(stmt)]
    return func(stmt, stack, regs, ops)

def assemble_stmt_assign(stmt: AssignMstmt, stack: List[Any], regs: Dict[str, Any], ops: Dict[str, Callable]):
    pass

def assemble_stmt_perform(stmt: PerformMstmt, stack: List[Any], regs: Dict[str, Any], ops: Dict[str, Callable]):
    pass

def assemble_stmt_test(stmt: TestMstmt, stack: List[Any], regs: Dict[str, Any], ops: Dict[str, Callable]):
    pass

def assemble_stmt_branch(stmt: BranchMstmt, stack: List[Any], regs: Dict[str, Any], ops: Dict[str, Callable]):
    pass

def assemble_stmt_goto(stmt: GotoMstmt, stack: List[Any], regs: Dict[str, Any], ops: Dict[str, Callable]):
    pass

def assemble_stmt_save(stmt: SaveMstmt, stack: List[Any], regs: Dict[str, Any], ops: Dict[str, Callable]):
    pass

def assemble_stmt_restore(stmt: RestoreMstmt, stack: List[Any], regs: Dict[str, Any], ops: Dict[str, Callable]):
    pass

update_assemble_stmt_rules({
    AssignMstmt: assemble_stmt_assign,
    PerformMstmt: assemble_stmt_perform,
    TestMstmt: assemble_stmt_test,
    BranchMstmt: assemble_stmt_branch,
    GotoMstmt: assemble_stmt_goto,
    SaveMstmt: assemble_stmt_save,
    RestoreMstmt: assemble_stmt_restore
})